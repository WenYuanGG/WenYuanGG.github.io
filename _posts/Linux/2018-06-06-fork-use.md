---
layout: post
title:  "[Linux C] 學習使用 fork 函數"
date:   2018-06-06
categories: [Linux]
comments: true
---

fork 是 Linux 系統中常用的<b>多工函數</b>, 而 fork 同時也是 Linux 的 System call (系統呼叫), 當你呼叫了 fork 函數後, 會創建一個和當前 process 一模一樣的<b>子程序</b>, 從而進行多工動作

<br/>

#### 什麼是程序 (process)
{: style="color:MediumSeaGreen;"}

在開始談 fork 之前, 必須要了解什麼是程序 (process):

- <b>程式碼 (program) ：</b> 假設你今天寫了是一支程式叫 example.c , 而且你尚未執行它, 則此時這支程式就叫 **program**

- <b>程序 (process) ：</b> 倘若你把 example.c 編譯並執行, 程式被載入記憶體, 而且進到作業系統排程執行時, 便稱為**程序**, 而且每個程序都會有自己專屬的編號, 叫做 **ProcessID**

所以 fork 就是把當前的 process (父程序) 又分支出另一個 process (子程序) , 而且父子程序長的一模一樣

<br/>

#### fork 的函數雛型 (man page 定義)
{: style="color:MediumSeaGreen;"}

{% highlight cpp %}
#include <unistd.h>
...
pid_t fork(void);
{% endhighlight %}

- `fork()` 可能會有以下三種回傳值：
    - <b>-1 ：</b> 發生錯誤
    - <b>0 ：</b> 代表為子程序
    - <b>大於 0 ：</b> 代表為父程序, 其回傳值子程序的 ProcessID

> 注意： 其回傳值是 **pid_t** , 不是 int 哦！

<br/>

#### 使用 fork 之後的現象
{: style="color:MediumSeaGreen;"}

當你的程序呼叫 `fork()` 函數時, 原本的程序 **(父程序)** 就會<b>分支出</b>另一支程序 **(子程序)** , 如下圖所示：

![](https://i.imgur.com/Pkyngmi.png)

- 我們可以試著練習下面<b>範例 1</b> ：

{% highlight cpp %}
/* example1.c */
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int main(){
    // 從呼叫 fork 開始, 會分成兩支程序多工進行
    pid_t PID = fork();

    switch(PID){
        // PID == -1 代表 fork 出錯
        case -1:
            perror("fork()");
            exit(-1);
        
        // PID == 0 代表是子程序
        case 0:
            printf("I'm Child process\n");
            printf("Child's PID is %d\n", getpid());
            break;
        
        // PID > 0 代表是父程序
        default:
            printf("I'm Parent process\n");
            printf("Parent's PID is %d\n", getpid());
    }

    return 0;
}
{% endhighlight %}

- 範例 1 執行結果：

![](https://i.imgur.com/41bzl1d.png)
